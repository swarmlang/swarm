call f:MAIN
exit

beginfn f:ETS_DEMO_ERROR_RANDOM_ERROR p:STRING
return "DemoError.RandomError"

-- This support is generated by the compiler automatically
beginfn f:EXCEPTION_TO_STRING p:STRING
	fnparam p:NUMBER $l:EXCODE
	scopeof $l:EXCOND

	$l:EXCOND <- equal $l:EXCODE 1
	callif $l:EXCOND f:ETS_DEMO_ERROR_RANDOM_ERROR
return "Unknown Exception"

beginfn f:EX_IS_DEMO_ERROR p:BOOLEAN
	fnparam p:NUMBER $l:EXCODE

	scopeof $l:EXCOND
	$l:EXCOND <- equal $l:EXCODE 1
return $l:EXCOND

beginfn f:MAYBE_RAISE_IF_RANDOM p:VOID
	raise $l:E_DEMO_ERROR_RANDOM_ERROR
return

beginfn f:MAYBE_RAISE p:NUMBER
	scopeof $l:RANDOM
	$l:RANDOM <- call f:RANDOM

	scopeof $l:RANDOM_LT_05
	$l:RANDOM_LT_05 <- lt $l:RANDOM 0.5

	callif $l:RANDOM_LT_05 f:MAYBE_RAISE_IF_RANDOM
return 3.14

-- Exception handler for the maybeRaise call
beginfn f:MAIN_EH p:VOID
	fnparam p:NUMBER $l:EXCODE

	scopeof $l:EXNAME
	$l:EXNAME <- call f:EXCEPTION_TO_STRING $l:EXCODE

	scopeof $l:MSG
	$l:MSG <- strconcat "Got an error: " $l:EXNAME

	out $l:MSG

	-- Call into the latter half of MAIN after handling the exception
	-- resume is used instead of call to assume the scope of the point
	-- in execution where the exception handler was registered
	resume f:MAIN1
return

beginfn f:MAIN1 p:VOID
	out "Done!"
return

beginfn f:MAIN0 p:VOID
	-- Register the exception handler for the maybeRaise() call
	scopeof $l:MAIN_EH_HANDLE
	$l:MAIN_EH_HANDLE <- pushexhandler f:MAIN_EH f:EX_IS_DEMO_ERROR

	-- Make the problematic call
	call f:MAYBE_RAISE

	-- Remove the exception handler
	popexhandler $l:MAIN_EH_HANDLE

	-- If we didn't get an exception, call the latter half of MAIN
	call f:MAIN1
return

beginfn f:MAIN p:VOID
	$l:E_DEMO_ERROR_RANDOM_ERROR <- 1

	call f:MAIN0
return
