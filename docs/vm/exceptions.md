# Exceptions

In the SVM, exceptions interrupt the control flow to handle unexpected cases. To the VM, an exception is nothing more than
an integer code which should be used to uniquely identify the exception type.

> Exception codes `0` through `499` are reserved by the SVM for exceptions generated by the VM or Prologue.
> See **Built-In Exceptions** below for details.

An SVI program can register handlers which catch and handle various exceptions before resuming control flow at some
new call in a program.

## Basic Exception Handling

An exception handler is a function of type `p:NUMBER -> p:VOID` which takes, as its only parameter, the code of the
exception that was thrown. When an exception is raised, the VM recurses up the scope and finds the nearest exception
handler that accepts the exception code (see **Filtering Exceptions** for more details). For example, here's a basic handler which prints a message:

```text
beginfn f:HANDLER p:VOID
    fnparam p:NUMBER $l:code
    scopeof $l:msg
    $l:msg <- call f:NUMBER_TO_STRING $l:code
    $l:msg <- strconcat "Handled exception: " $l:msg
    err $l:msg
return
```

We can trigger this handler by raising an exception with some arbitrary code after registering the handler:

```text
pushexhandler f:HANDLER
raise 500
out "After?"
```

This produces the following (abridged) output:

```text
   debug VM: pushexhandler Location<f:HANDLER>
   debug VM: raise NumberReference<500.000000>
   debug VM: Location<l:msg> <- StringReference<Handled exception: 500.000000>
   debug VM: streampush Location<s:STDERR> Location<l:msg>
   debug VM: return0
```

Notice, however, that the program execution halted after `f:HANDLER` returned. If we want the program to resume
execution after the exception handler completes, we need to use the `resume` instruction.

`resume` is a special form of `call` which can only be used during exception handling. When executed, `resume` will
call the specified function. But, instead of creating a new scope for the call, **the function will execute as if it
inherited the scope where the `pushexhandler` instruction was called**.

This allows your exception handlers to resume execution at the place where the exception was handled. Here's an example:

```text
beginfn f:HANDLER p:VOID
    fnparam p:NUMBER $l:code
    scopeof $l:msg
    $l:msg <- call f:NUMBER_TO_STRING $l:code
    $l:msg <- strconcat "Handled exception: " $l:msg
    err $l:msg
    resume f:AFTER
return

pushexhandler f:HANDLER
raise 500
out "After?"

beginfn f:AFTER p:VOID
    out "After handler!"
return
```

This will output something like:

```text
   debug VM: pushexhandler Location<f:HANDLER>
   debug VM: raise NumberReference<500.000000>
   debug VM: Location<l:msg> <- StringReference<Handled exception: 500.000000>
   debug VM: streampush Location<s:STDERR> Location<l:msg>
   debug VM: resume Location<f:AFTER>
   debug VM: streampush Location<s:STDOUT> StringReference<After handler!>
   debug VM: return0
```

## Scope Inheritance

The `resume` instruction performs an SVM operation called "scope inheritance." This means that the resumed function _replaces_
the `IFunctionCall` in the scope where the exception handler was registered, allowing the program execution to proceed normally
for any scopes higher than that one.

This core principal is what enables the program to fully capture and gracefully handle an exception w/o the upper scopes
having any knowledge of it.

**An important side-effect of scope inheritance:** because the function _replaces_ the original call, it must satisfy the
return-type of the original call. Here's an example:

```text
beginfn f:HANDLER p:VOID
    fnparam p:NUMBER $l:code
    resume f:AFTER
return

beginfn f:DANGEROUS p:NUMBER
    pushexhandler f:HANDLER
    raise 500
return 3.14

beginfn f:AFTER p:NUMBER
return 3.2
```

In this case, the exception handler is registered w/in the scope of `f:DANGEROUS`, which has the return type `p:NUMBER`.
As a result, the `resume`-d function `f:AFTER` must also return type `p:NUMBER`.

In this case, `call f:DANGEROUS` would return `3.2`.

Notably, the `resume` instruction can be called from w/in any nested call of an exception handler:

```text
beginfn f:HANDLER_INNER p:VOID
    resume f:AFTER
return

beginfn f:HANDLER p:VOID
    fnparam p:NUMBER $l:code
    call f:HANDLER_INNER
return

pushexhandler f:HANDLER
raise 500

beginfn f:AFTER p:VOID
    out "After!"
return
```

## Filtering Exceptions

Sometimes, you may want to register an exception handler which only handles some exceptions, allowing
others to be handled by previously-registered handlers. To do this, you can pass a discriminator function
to `pushexhandler`. This function is of type `p:NUMBER -> p:BOOLEAN`. It takes the exception code and returns
true if the handler should handle that code.

For example, here's a handler which only accepts user-defined exceptions. It does not catch internal exceptions (`0` through `499`):

```text
beginfn f:HANDLER p:VOID
    fnparam p:NUMBER $l:code
    scopeof $l:msg
    $l:msg <- call f:NUMBER_TO_STRING $l:code
    $l:msg <- strconcat "Handled exception: " $l:code
    err $l:msg
return

beginfn f:HANDLER_ACCEPT p:VOID
    $l:accept <- true
return

beginfn f:HANDLER_DISC p:BOOLEAN
    fnparam p:NUMBER $l:code
    scopeof $l:accept
    $l:accept <- false
    
    scopeof $l:cond
    $l:cond <- gte $l:code 500
    
    callif $l:cond f:HANDLER_ACCEPT
return $l:accept

pushexhandler f:HANDLER f:HANDLER_DISC
```

## Un-Registering Exception Handlers

Exception handlers are automatically limited to the scope where they are registered. As a result, you should rarely need
to manually remove them. Instead, they will be removed when the scope ends.

However, in case you do, the `pushexhandler` instruction returns a unique identifier for the handler which can be passed
to `popexhandler` to manually remove it:

```text
beginfn f:HANDLER p:VOID
    fnparam p:NUMBER $l:code
    err "Error!"
return

$l:handler_id <- pushexhandler f:HANDLER
popexhandler $l:handler_id
```

## `pushexhandler`/`resume` With Parameters

The SVM provides no native way of passing parameters to exception handlers or `resume`-d functions. However, because SVI
allows partial application via the `curry` instruction, which allows a basic form of parameterization.

For example, here's an exception handler which takes the `resume` type and target as a parameter:

```text
beginfn f:P_HANDLER p:VOID
    fnparam p:TYPE $l:resumetype
    fnparam $l:resumetype $l:resume
    fnparam p:NUMBER $l:code
    err "Error!"
    resume $l:resume
return

$l:resumetype <- call f:LAMBDA0 p:VOID
$l:exh <- curry f:P_HANDLER $l:resumetype
$l:exh <- curry $l:exh f:AFTER
pushexhandler $l:exh
raise 500

beginfn f:AFTER p:VOID
    out "Resume"
return
```

Similarly, we can pass parameters to `resume`-d functions. For example, here's a resume function which accepts an error
message as a parameter:

```text
beginfn f:HANDLER p:VOID
    fnparam p:NUMBER $l:code
    scopeof $l:msg
    $l:msg <- call f:NUMBER_TO_STRING $l:code
    $l:msg <- strconcat "Exception: " $l:msg
    
    scopeof $l:resume
    $l:resume <- curry f:AFTER $l:msg
    resume $l:resume
return

pushexhandler f:HANDLER
raise 500

beginfn f:AFTER p:VOID
    fnparam p:STRING $l:msg
    $l:msg <- strconcat "Recovered from: " $l:msg
    out $l:msg
return
```

## Built-In Exceptions

Exception codes `0` through `499` are reserved by the SVM for exceptions generated by the VM or Prologue.

**Exception codes**

| Code | Description                                                                         |
|------|-------------------------------------------------------------------------------------|
| 5    | Invalid parameter type in function call                                             |
| 6    | Type error                                                                          |
| 7    | Invalid reference implementation (value has correct type, but cannot be cast to IR) |
| 8    | Division by zero                                                                    |
| 9    | `while` callback has invalid type                                                   |
| 10   | `with` callback has invalid type                                                    |
| 11   | Enumeration index out-of-bounds                                                     |
| 12   | `enumerate` callback has invalid type                                               |
| 13   | Attempted to load `fnparam` outside call context                                    |
| 14   | Attempted to `return` outside call context                                          |
| 15   | Invalid key for map                                                                 |
| 16   | Attempted to assign result of instruction which does not yield a value              |
| 17   | Stream not open                                                                     |
| 18   | Attempted to pop from empty stream                                                  |
| 19   | Attempted to `resume` outside exception handler context                             |
| 20   | Attempted to clone a non-replicable resource                                        |
| 21   | Invalid value for `enumeration` insert                                              |
| 22   | Attempted to perform privileged operation on resource not owned by current control  |
| 23   | Attempted to re-publish an existing resource                                        |
| 24   | Attempted to open invalid or missing file path                                      |
| 25   | Exception handler has invalid type                                                  |
| 26   | Exceeded max attempts when acquiring lock                                           |
| 27   | Attempted to mutate a finalized object type                                         |
| 28   | Child object property type conflicts with parent object property type               |
| 29   | Attempted to subset non-final object type                                           |
