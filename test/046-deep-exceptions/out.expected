[35m   debug [39m[0m[vm] Skipping uncalled function body: BEGINFN<Location<f:HANDLER>, TypeReference<Primitive<VOID>>>, pc: 9
[35m   debug [39m[0m[vm] Skipping uncalled function body: BEGINFN<Location<f:DANGEROUS_THROW>, TypeReference<Primitive<VOID>>>, pc: 13
[35m   debug [39m[0m[vm] Skipping uncalled function body: BEGINFN<Location<f:DANGEROUS_SAFE>, TypeReference<Primitive<VOID>>>, pc: 16
[35m   debug [39m[0m[vm] Skipping uncalled function body: BEGINFN<Location<f:DANGEROUS>, TypeReference<Primitive<NUMBER>>>, pc: 25
[35m   debug [39m[0m[vm] Skipping uncalled function body: BEGINFN<Location<f:RESUMED>, TypeReference<Primitive<NUMBER>>>, pc: 28
[35m   debug [39m[0m[vm] Skipping uncalled function body: BEGINFN<Location<f:OUTER>, TypeReference<Primitive<NUMBER>>>, pc: 34
[35m   debug [39m[0m[vm] streampush Location<s:STDOUT> StringReference<Calling outer...>
[35m   debug [39m[0m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[0m[vm] assigneval Location<l:outerResult> CALL1<Location<f:OUTER>, NumberReference<4.000000>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumping to call
[35m   debug [39m[0m[vm] call1 Location<f:OUTER> NumberReference<4.000000>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] load inline function: OUTER (#params: 1) (returns: TypeReference<Primitive<NUMBER>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:OUTER, rt: Primitive<NUMBER>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:OUTER> (pc: 28)
[35m   debug [39m[0m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:in>>
[35m   debug [39m[0m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] fnparam: Location<l:in> <- NumberReference<4.000000>
[35m   debug [39m[0m[vm] pushexhandler Location<f:HANDLER>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[0m[vm] load inline function: HANDLER (#params: 1) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:HANDLER, rt: Primitive<VOID>>>
[35m   debug [39m[0m[vm] scopeof Location<l:pi>
[35m   debug [39m[0m[vm] assigneval Location<l:pi> CALL1<Location<f:DANGEROUS>, Location<l:in>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumping to call
[35m   debug [39m[0m[vm] call1 Location<f:DANGEROUS> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] load inline function: DANGEROUS (#params: 1) (returns: TypeReference<Primitive<NUMBER>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:DANGEROUS, rt: Primitive<NUMBER>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:DANGEROUS> (pc: 16)
[35m   debug [39m[0m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:in>>
[35m   debug [39m[0m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] fnparam: Location<l:in> <- NumberReference<4.000000>
[35m   debug [39m[0m[vm] scopeof Location<l:dangerous_out>
[35m   debug [39m[0m[vm] scopeof Location<l:cond>
[35m   debug [39m[0m[vm] assigneval Location<l:cond> LT<Location<l:in>, NumberReference<1.000000>>
[35m   debug [39m[0m[vm] lt Location<l:in> NumberReference<1.000000>
[35m   debug [39m[0m[vm] ensureNumber: NumberReference<4.000000>
[35m   debug [39m[0m[vm] ensureNumber: NumberReference<1.000000>
[35m   debug [39m[0m[vm] Location<l:cond> <- BooleanReference<false>
[35m   debug [39m[0m[vm] callif0 Location<l:cond> Location<f:DANGEROUS_THROW>
[35m   debug [39m[0m[vm] ensureBoolean: BooleanReference<false>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[0m[vm] load inline function: DANGEROUS_THROW (#params: 0) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:DANGEROUS_THROW, rt: Primitive<VOID>>>
[35m   debug [39m[0m[vm] callelse0 Location<l:cond> Location<f:DANGEROUS_SAFE>
[35m   debug [39m[0m[vm] ensureBoolean: BooleanReference<false>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[0m[vm] load inline function: DANGEROUS_SAFE (#params: 0) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:DANGEROUS_SAFE, rt: Primitive<VOID>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:DANGEROUS_SAFE> (pc: 13)
[35m   debug [39m[0m[vm] next instruction for inline call: ASSIGNVALUE<Location<l:dangerous_out>, NumberReference<3.141000>>
[35m   debug [39m[0m[vm] assignvalue Location<l:dangerous_out> NumberReference<3.141000>
[35m   debug [39m[0m[vm] Location<l:dangerous_out> <- NumberReference<3.141000>
[35m   debug [39m[0m[vm] return0
[35m   debug [39m[0m[vm] streampush Location<s:STDOUT> StringReference<After cond call>
[35m   debug [39m[0m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[0m[vm] return1 Location<l:dangerous_out>
[35m   debug [39m[0m[vm] assigneval Location<l:pi> CALL1<Location<f:DANGEROUS>, Location<l:in>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumped from return
[35m   debug [39m[0m[vm] Location<l:pi> <- NumberReference<3.141000>
[35m   debug [39m[0m[vm] return1 Location<l:pi>
[35m   debug [39m[0m[vm] assigneval Location<l:outerResult> CALL1<Location<f:OUTER>, NumberReference<4.000000>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumped from return
[35m   debug [39m[0m[vm] Location<l:outerResult> <- NumberReference<3.141000>
[35m   debug [39m[0m[vm] assigneval Location<l:outerResult> CALL1<Location<f:OUTER>, NumberReference<0.000000>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumping to call
[35m   debug [39m[0m[vm] call1 Location<f:OUTER> NumberReference<0.000000>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] load inline function: OUTER (#params: 1) (returns: TypeReference<Primitive<NUMBER>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:OUTER, rt: Primitive<NUMBER>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:OUTER> (pc: 28)
[35m   debug [39m[0m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:in>>
[35m   debug [39m[0m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] fnparam: Location<l:in> <- NumberReference<0.000000>
[35m   debug [39m[0m[vm] pushexhandler Location<f:HANDLER>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[0m[vm] load inline function: HANDLER (#params: 1) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:HANDLER, rt: Primitive<VOID>>>
[35m   debug [39m[0m[vm] scopeof Location<l:pi>
[35m   debug [39m[0m[vm] assigneval Location<l:pi> CALL1<Location<f:DANGEROUS>, Location<l:in>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumping to call
[35m   debug [39m[0m[vm] call1 Location<f:DANGEROUS> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] load inline function: DANGEROUS (#params: 1) (returns: TypeReference<Primitive<NUMBER>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:DANGEROUS, rt: Primitive<NUMBER>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:DANGEROUS> (pc: 16)
[35m   debug [39m[0m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:in>>
[35m   debug [39m[0m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] fnparam: Location<l:in> <- NumberReference<0.000000>
[35m   debug [39m[0m[vm] scopeof Location<l:dangerous_out>
[35m   debug [39m[0m[vm] scopeof Location<l:cond>
[35m   debug [39m[0m[vm] assigneval Location<l:cond> LT<Location<l:in>, NumberReference<1.000000>>
[35m   debug [39m[0m[vm] lt Location<l:in> NumberReference<1.000000>
[35m   debug [39m[0m[vm] ensureNumber: NumberReference<0.000000>
[35m   debug [39m[0m[vm] ensureNumber: NumberReference<1.000000>
[35m   debug [39m[0m[vm] Location<l:cond> <- BooleanReference<true>
[35m   debug [39m[0m[vm] callif0 Location<l:cond> Location<f:DANGEROUS_THROW>
[35m   debug [39m[0m[vm] ensureBoolean: BooleanReference<true>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[0m[vm] load inline function: DANGEROUS_THROW (#params: 0) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:DANGEROUS_THROW, rt: Primitive<VOID>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:DANGEROUS_THROW> (pc: 9)
[35m   debug [39m[0m[vm] next instruction for inline call: RAISE<NumberReference<0.000000>>
[35m   debug [39m[0m[vm] raise NumberReference<0.000000>
[35m   debug [39m[0m[vm] ensureNumber: NumberReference<0.000000>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:HANDLER> (pc: 0)
[35m   debug [39m[0m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:code>>
[35m   debug [39m[0m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:code>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] fnparam: Location<l:code> <- NumberReference<0.000000>
[35m   debug [39m[0m[vm] scopeof Location<l:msg>
[35m   debug [39m[0m[vm] assigneval Location<l:msg> CALL1<Location<f:NUMBER_TO_STRING>, Location<l:code>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumping to call
[35m   debug [39m[0m[vm] call1 Location<f:NUMBER_TO_STRING> Location<l:code>
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<NumberToStringFunction<>>
[35m   debug [39m[0m[vm] provider call: NumberToStringFunctionCall<>
[35m   debug [39m[0m[vm] assigneval Location<l:msg> CALL1<Location<f:NUMBER_TO_STRING>, Location<l:code>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumped from return
[35m   debug [39m[0m[vm] Location<l:msg> <- StringReference<0.000000>
[35m   debug [39m[0m[vm] assigneval Location<l:msg> STRCONCAT<StringReference<Handled: >, Location<l:msg>>
[35m   debug [39m[0m[vm] strconcat StringReference<Handled: > Location<l:msg>
[35m   debug [39m[0m[vm] ensureString: StringReference<Handled: >
[35m   debug [39m[0m[vm] ensureString: StringReference<0.000000>
[35m   debug [39m[0m[vm] Location<l:msg> <- StringReference<Handled: 0.000000>
[35m   debug [39m[0m[vm] streampush Location<s:STDOUT> Location<l:msg>
[35m   debug [39m[0m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[0m[vm] resume Location<f:RESUMED>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] load inline function: RESUMED (#params: 0) (returns: TypeReference<Primitive<NUMBER>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:RESUMED, rt: Primitive<NUMBER>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:RESUMED> (pc: 25)
[35m   debug [39m[0m[vm] next instruction for inline call: STREAMPUSH<Location<s:STDOUT>, StringReference<An error occurred. Estimating!>>
[35m   debug [39m[0m[vm] streampush Location<s:STDOUT> StringReference<An error occurred. Estimating!>
[35m   debug [39m[0m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[0m[vm] return1 NumberReference<3.200000>
[35m   debug [39m[0m[vm] assigneval Location<l:outerResult> CALL1<Location<f:OUTER>, NumberReference<0.000000>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumped from return
[35m   debug [39m[0m[vm] Location<l:outerResult> <- NumberReference<3.200000>
[35m   debug [39m[0m[vm] assigneval Location<l:outerResult> CALL1<Location<f:OUTER>, NumberReference<5.000000>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumping to call
[35m   debug [39m[0m[vm] call1 Location<f:OUTER> NumberReference<5.000000>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] load inline function: OUTER (#params: 1) (returns: TypeReference<Primitive<NUMBER>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:OUTER, rt: Primitive<NUMBER>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:OUTER> (pc: 28)
[35m   debug [39m[0m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:in>>
[35m   debug [39m[0m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] fnparam: Location<l:in> <- NumberReference<5.000000>
[35m   debug [39m[0m[vm] pushexhandler Location<f:HANDLER>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[0m[vm] load inline function: HANDLER (#params: 1) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:HANDLER, rt: Primitive<VOID>>>
[35m   debug [39m[0m[vm] scopeof Location<l:pi>
[35m   debug [39m[0m[vm] assigneval Location<l:pi> CALL1<Location<f:DANGEROUS>, Location<l:in>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumping to call
[35m   debug [39m[0m[vm] call1 Location<f:DANGEROUS> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] load inline function: DANGEROUS (#params: 1) (returns: TypeReference<Primitive<NUMBER>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:DANGEROUS, rt: Primitive<NUMBER>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:DANGEROUS> (pc: 16)
[35m   debug [39m[0m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:in>>
[35m   debug [39m[0m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:in>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[0m[vm] fnparam: Location<l:in> <- NumberReference<5.000000>
[35m   debug [39m[0m[vm] scopeof Location<l:dangerous_out>
[35m   debug [39m[0m[vm] scopeof Location<l:cond>
[35m   debug [39m[0m[vm] assigneval Location<l:cond> LT<Location<l:in>, NumberReference<1.000000>>
[35m   debug [39m[0m[vm] lt Location<l:in> NumberReference<1.000000>
[35m   debug [39m[0m[vm] ensureNumber: NumberReference<5.000000>
[35m   debug [39m[0m[vm] ensureNumber: NumberReference<1.000000>
[35m   debug [39m[0m[vm] Location<l:cond> <- BooleanReference<false>
[35m   debug [39m[0m[vm] callif0 Location<l:cond> Location<f:DANGEROUS_THROW>
[35m   debug [39m[0m[vm] ensureBoolean: BooleanReference<false>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[0m[vm] load inline function: DANGEROUS_THROW (#params: 0) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:DANGEROUS_THROW, rt: Primitive<VOID>>>
[35m   debug [39m[0m[vm] callelse0 Location<l:cond> Location<f:DANGEROUS_SAFE>
[35m   debug [39m[0m[vm] ensureBoolean: BooleanReference<false>
[35m   debug [39m[0m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[0m[vm] load inline function: DANGEROUS_SAFE (#params: 0) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[0m[vm] ensureFunction: FunctionReference<InlineFunction<f:DANGEROUS_SAFE, rt: Primitive<VOID>>>
[35m   debug [39m[0m[vm] inline call: InlineFunctionCall<f:DANGEROUS_SAFE> (pc: 13)
[35m   debug [39m[0m[vm] next instruction for inline call: ASSIGNVALUE<Location<l:dangerous_out>, NumberReference<3.141000>>
[35m   debug [39m[0m[vm] assignvalue Location<l:dangerous_out> NumberReference<3.141000>
[35m   debug [39m[0m[vm] Location<l:dangerous_out> <- NumberReference<3.141000>
[35m   debug [39m[0m[vm] return0
[35m   debug [39m[0m[vm] streampush Location<s:STDOUT> StringReference<After cond call>
[35m   debug [39m[0m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[0m[vm] return1 Location<l:dangerous_out>
[35m   debug [39m[0m[vm] assigneval Location<l:pi> CALL1<Location<f:DANGEROUS>, Location<l:in>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumped from return
[35m   debug [39m[0m[vm] Location<l:pi> <- NumberReference<3.141000>
[35m   debug [39m[0m[vm] return1 Location<l:pi>
[35m   debug [39m[0m[vm] assigneval Location<l:outerResult> CALL1<Location<f:OUTER>, NumberReference<5.000000>>
[35m   debug [39m[0m[vm] assignEval: got call0 or call1
[35m   debug [39m[0m[vm] assignEval: jumped from return
[35m   debug [39m[0m[vm] Location<l:outerResult> <- NumberReference<3.141000>
[35m   debug [39m[0m[vm] streampush Location<s:STDOUT> StringReference<After outer!>
[35m   debug [39m[0m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
