[35m   debug [39m[vm] Skipping uncalled function body: BEGINFN<Location<f:HANDLER1>, TypeReference<Primitive<VOID>>>, pc: 8
[35m   debug [39m[vm] assigneval Location<l:h1> PUSHEXHANDLER1<Location<f:HANDLER1>>
[35m   debug [39m[vm] pushexhandler Location<f:HANDLER1>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[vm] load inline function: HANDLER1 (#params: 1) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[vm] ensureFunction: FunctionReference<InlineFunction<f:HANDLER1, rt: Primitive<VOID>>>
[35m   debug [39m[vm] Location<l:h1> <- StringReference<69149336-f3d4-4d5e-b705-b860e1fb7b98>
[35m   debug [39m[vm] assigneval Location<l:bad> DIVIDE<NumberReference<14.000000>, NumberReference<0.000000>>
[35m   debug [39m[vm] divide NumberReference<14.000000> NumberReference<0.000000>
[35m   debug [39m[vm] ensureNumber: NumberReference<14.000000>
[35m   debug [39m[vm] ensureNumber: NumberReference<0.000000>
[31m   error [39m[0m[vm] Runtime error: Attempted to divide by zero (RuntimeExCode(DivisionByZero, code: 8))
[35m   debug [39m[vm] inline call: InlineFunctionCall<f:HANDLER1> (pc: 0)
[35m   debug [39m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:code>>
[35m   debug [39m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:code>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[vm] fnparam: Location<l:code> <- NumberReference<8.000000>
[35m   debug [39m[vm] scopeof Location<l:msg>
[35m   debug [39m[vm] assigneval Location<l:msg> CALL1<Location<f:NUMBER_TO_STRING>, Location<l:code>>
[35m   debug [39m[vm] assignEval: got call0 or call1
[35m   debug [39m[vm] assignEval: jumping to call
[35m   debug [39m[vm] call1 Location<f:NUMBER_TO_STRING> Location<l:code>
[35m   debug [39m[vm] ensureFunction: FunctionReference<NumberToStringFunction<>>
[35m   debug [39m[vm] provider call: NumberToStringFunctionCall<>
[35m   debug [39m[vm] assigneval Location<l:msg> CALL1<Location<f:NUMBER_TO_STRING>, Location<l:code>>
[35m   debug [39m[vm] assignEval: got call0 or call1
[35m   debug [39m[vm] assignEval: jumped from return
[35m   debug [39m[vm] Location<l:msg> <- StringReference<8.000000>
[35m   debug [39m[vm] assigneval Location<l:msg> STRCONCAT<StringReference<Handled: >, Location<l:msg>>
[35m   debug [39m[vm] strconcat StringReference<Handled: > Location<l:msg>
[35m   debug [39m[vm] ensureString: StringReference<Handled: >
[35m   debug [39m[vm] ensureString: StringReference<8.000000>
[35m   debug [39m[vm] Location<l:msg> <- StringReference<Handled: 8.000000>
[35m   debug [39m[vm] streampush Location<s:STDOUT> Location<l:msg>
[35m   debug [39m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[vm] resume Location<f:AFTER1>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[vm] load inline function: AFTER1 (#params: 0) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[vm] ensureFunction: FunctionReference<InlineFunction<f:AFTER1, rt: Primitive<VOID>>>
[35m   debug [39m[vm] inline call: InlineFunctionCall<f:AFTER1> (pc: 19)
[35m   debug [39m[vm] next instruction for inline call: STREAMPUSH<Location<s:STDOUT>, StringReference<After 1!>>
[35m   debug [39m[vm] streampush Location<s:STDOUT> StringReference<After 1!>
[35m   debug [39m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[vm] popexhandler Location<l:h1>
[35m   debug [39m[vm] ensureString: StringReference<69149336-f3d4-4d5e-b705-b860e1fb7b98>
[35m   debug [39m[vm] pushexhandler Location<f:HANDLER2>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[vm] load inline function: HANDLER2 (#params: 1) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[vm] ensureFunction: FunctionReference<InlineFunction<f:HANDLER2, rt: Primitive<VOID>>>
[35m   debug [39m[vm] resume Location<f:HANDLER1>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[vm] load inline function: HANDLER1 (#params: 1) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[vm] ensureFunction: FunctionReference<InlineFunction<f:HANDLER1, rt: Primitive<VOID>>>
[31m   error [39m[0m[vm] Runtime error: Attempted to call `resume` from outside context of exception handler (RuntimeExCode(ResumeOutsideExHandler, code: 19))
[35m   debug [39m[vm] inline call: InlineFunctionCall<f:HANDLER2> (pc: 11)
[35m   debug [39m[vm] next instruction for inline call: FNPARAM<TypeReference<Primitive<NUMBER>>, Location<l:code>>
[35m   debug [39m[vm] fnparam TypeReference<Primitive<NUMBER>> Location<l:code>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<NUMBER>>
[35m   debug [39m[vm] fnparam: Location<l:code> <- NumberReference<19.000000>
[35m   debug [39m[vm] scopeof Location<l:msg>
[35m   debug [39m[vm] assigneval Location<l:msg> CALL1<Location<f:NUMBER_TO_STRING>, Location<l:code>>
[35m   debug [39m[vm] assignEval: got call0 or call1
[35m   debug [39m[vm] assignEval: jumping to call
[35m   debug [39m[vm] call1 Location<f:NUMBER_TO_STRING> Location<l:code>
[35m   debug [39m[vm] ensureFunction: FunctionReference<NumberToStringFunction<>>
[35m   debug [39m[vm] provider call: NumberToStringFunctionCall<>
[35m   debug [39m[vm] assigneval Location<l:msg> CALL1<Location<f:NUMBER_TO_STRING>, Location<l:code>>
[35m   debug [39m[vm] assignEval: got call0 or call1
[35m   debug [39m[vm] assignEval: jumped from return
[35m   debug [39m[vm] Location<l:msg> <- StringReference<19.000000>
[35m   debug [39m[vm] assigneval Location<l:msg> STRCONCAT<StringReference<Handled: >, Location<l:msg>>
[35m   debug [39m[vm] strconcat StringReference<Handled: > Location<l:msg>
[35m   debug [39m[vm] ensureString: StringReference<Handled: >
[35m   debug [39m[vm] ensureString: StringReference<19.000000>
[35m   debug [39m[vm] Location<l:msg> <- StringReference<Handled: 19.000000>
[35m   debug [39m[vm] streampush Location<s:STDOUT> Location<l:msg>
[35m   debug [39m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[vm] resume Location<f:AFTER2>
[35m   debug [39m[vm] ensureType: TypeReference<Primitive<VOID>>
[35m   debug [39m[vm] load inline function: AFTER2 (#params: 0) (returns: TypeReference<Primitive<VOID>>)
[35m   debug [39m[vm] ensureFunction: FunctionReference<InlineFunction<f:AFTER2, rt: Primitive<VOID>>>
[35m   debug [39m[vm] inline call: InlineFunctionCall<f:AFTER2> (pc: 26)
[35m   debug [39m[vm] next instruction for inline call: STREAMPUSH<Location<s:STDOUT>, StringReference<After 2!>>
[35m   debug [39m[vm] streampush Location<s:STDOUT> StringReference<After 2!>
[35m   debug [39m[vm] ensureStream: StreamReference<SingleThreaded::Stream<of: Primitive<STRING>>>
[35m   debug [39m[vm] return0
